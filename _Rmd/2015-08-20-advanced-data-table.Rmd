---
layout: post
title: Advanced Tips & Tricks with data.table
date: 2015-08-20
categories: articles
tags: [data-science, R, data.table]
comments: true
share: true
---
  
* Table of Contents
{:toc}

## Tips and tricks learned along the way 

This is mostly a running list of neat `data.table` tricks that took me a while to figure out either by digging into the [official documentation], adapting StackOverflow posts, or more often than not, experimenting for hours.  I'd like to persist these discoveries somewhere with more memory than my head (hello internet) so I can reuse them after my mental memory runs out.  A messier version of DataCamp's sweet [cheat sheet](https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf).

Most, if not all of these techniques were developed for real data science projects and provided some value to my data engineering.  I've generalized everything to the `mtcars` dataset which might not make this value immediately clear.  This list is not intented to be comprehensive or a representative sample of data.table's functionality as DataCamp's cheatsheet is.  OK, enough disclaimers!



## hide output from `:=` with knitr

## using lists as columns3

### Way one
```{r}
dt <- data.table(mtcars)

# Add all categories of `gear` for each `cyl` to original data.table as a list
dt[,gearsL:=list(list(unique(gear))), by=.(cyl)]

# first element of list of each row
#(this isnt that useful, but explores how to access elements of columns which are constructed of lists of lists.  `lapply` is your friend).
dt[,gearL1:=lapply(gear, function(x) x[[1]])]

# calculate all the gears for all cars of each cyl (excluding the current current row).
# This can be useful for comparing observations to the mean of groups, where the group mean is not biased by the observation of interest.
dt[,other_gear:=mapply(function(x, y) setdiff(x, y) ,x=gearsL, y=gear)]

# actually calculate a group function excluding the observations of interest



## METHOD 1: THIS WORKS, but should be a way with .BY

# 1.a without setting key
dt <- data.table(mtcars)
dt[, dt[!gear %in% unique(dt$gear)[.GRP], mean(mpg), by=cyl], by=gear] #unbiased mean

# 1.a without setting key longway
uid <- unique(dt$gear)
dt[, dt[!gear %in% (uid[.GRP]), mean(mpg), by=cyl] , by=gear][order(cyl, gear)] #unbiased mean

# 1.a pulling it apart with .GRP
dt[, .GRP, by=cyl]
dt[, .(.GRP, unique(dt$gear)[.GRP]), by=cyl]
dt[,dt[, .(.GRP, unique(dt$gear)[.GRP]), by=cyl], by=gear]

# 1.b setting key
setkey(dt, gear)
uid <- unique(dt$gear)
dt[, dt[!.(uid[.GRP]), mean(mpg), by=cyl] , by=gear] #unbiased mean

mean(dt[cyl==4 & gear!=3,mpg]) # testing
mean(dt[cyl==6 & gear!=3,mpg]) # testing

dt[, mpg_biased_mean:=mean(mpg), by=cyl] # for comparison

## METHOD 2: THIS ALSO WORKS
dt[,  .SD[, mean(mpg)], by=gear] 
dt[,  .SD[, mean(mpg), by=cyl], by=gear]
dt[,  {uid=unique(cyl); .SD[, mean(mpg), by=cyl]} , by=gear]

dt[,{
  vbar = sum(mpg)
  n = .N
  .SD[,.(n, .N, sum_in_gear_cyl=sum(mpg), sum_in_cyl=vbar), by=gear]
} , by=cyl]

dt[,sum(mpg), by=cyl] # test

dt[,{
  vbar = mean(mpg)
  n = .N
  .SD[,(n*vbar-sum(mpg))/(n-.N),by=gear]
} , by=cyl]

### METHOD 3 : Super Fast Mean calculation

# non-function direct way
dt <- data.table(mtcars)[,.(mpg,cyl,gear)]
dt[,`:=`(avg_mpg_cyl=mean(mpg), Ncyl=.N), by=cyl]
dt[,`:=`(Ncylgear=.N, avg_mpg_cyl_gear=mean(mpg)), by=.(cyl, gear)]
dt[,unbmean:=(avg_mpg_cyl*Ncyl-(Ncylgear*avg_mpg_cyl_gear))/(Ncyl-Ncylgear)]
setkey(dt, cyl, gear)  
dt

# function way
leaveOneOutMean <- function(dt, ind, bybig, bysmall) {
  tmp <- copy(dt)
  tmp[,`:=`(avg_mpg_cyl=mean(get(ind)), Ncyl=.N), by=.(get(bybig))]
  tmp[,`:=`(Ncylgear=.N, avg_mpg_cyl_gear=mean(get(ind))), by=.(get(bybig), get(bysmall))]
  ret <- tmp[,(avg_mpg_cyl*Ncyl-(Ncylgear*avg_mpg_cyl_gear))/(Ncyl-Ncylgear)]
  print(class(ret))
  return(ret)
}

dt <- data.table(mtcars)
dt[,unbiased_mean:=leaveOneOutMean(.SD, ind='mpg', bybig='cyl', bysmall='gear')]
dt[,biased_mean:=mean(mpg), by=cyl]

### SPEED CHECK
dt <- data.table(mtcars)
dt <- dt[sample(1:.N, 100000, replace=T), ] # increase # of rows in mtcars
dt$gear <- sample(1:300, nrow(dt), replace=T) # adding in more cateogries

system.time(dt[,unbiased_mean_vectorized:=leaveOneOutMean(.SD, ind='mpg', bybig='cyl', bysmall='gear')])
system.time(tmp <- dt[,dt[!gear %in% unique(dt$gear)[.GRP], mean(mpg), by=cyl], by=gear] )

rm(list=ls())
dat <- data.table(mtcars)





```

### Way 2
 need to split up big chunk atop

## passing `data.table` column names as function arguments 

## beware of scoping within data.table

data.table is greedy


When you add a column to a `data.frame` within a function that exists in the global environment
```{r}
df <- mtcars
add_column_df <- function(df, addcol='') {
  df[,addcol] <- 'Hi!'
  print(head(df))
  return('hello')
}
add_column_df(df, addcol='thing')
head(df)
```

:= 

## create multiple columns with `:=` in one statement

```{r}
dt <- data.table(mtcars)
dt[,`:=`(avg=mean(mpg), med=median(mpg), min=min(mpg)), by=cyl]

```
## append categories into list

```{r}
dt <- data.table(mtcars)
```

##### summary table (long and narrow)
This could be useful, but is easily achievable using traditional methods
```{r}
dt[,list(unique(gear)), by=.(cyl)]
```

##### summary table (short and narrow)
This is more nifty.  It's so simple, I find myself using this trick to quickly explore data ad hoc at the command line.
Can also be useful for more serious data engineering.
```{r}
dt[,list(list(unique(gear))), by=.(cyl)]
```

##### append to original mtcars data.table
Could be useful if you want to persist this information for further manipulation.
```{r}
dt[,gears_unique:=list(list(unique(gear))), by=.(cyl)]
```

#### TESTING
dt[,gearsL:=list(list(unique(gear))), by=.(cyl)]
dt[,gearsLx:=lapply(gear, function(x) setdiff(gearsL[[1]], x))]


## Using `[1]`, `[.N]`, `setkey` and `by` for within group subsetting

##### subset rows within by statement 
`V1` is the standard deviation of `mpg` by `cyl`.  `V2` is the standard deviation of `mpg` for just the first half of `mpg`.
```{r}
dt <- data.table(mtcars)
setkey(dt,mpg)
dt[, .(sd(mpg), sd(mpg[1:round(.N/2)])), by=cyl]
```

### take highest value of column A when column B is highest by group

##### max of `qsec` for each category of `cyl`
(this is easy)
```{r}
dt <- data.table(mtcars)
dt[, max(qsec), by=cyl]
```

##### value of `qsec `when `mpg` is the highest per category of `cyl`
(this is trickier)

```{r}
setkey(dt, mpg)
dt[,qsec[.N],  by=cyl]
```


##### value of `qsec` when `mpg` is the lowest per category of `cyl`
```{r}
dt[,qsec[1],  by=cyl]
```

##### value of `qsec` when `mpg` is the median per category of `cyl`
```{r}
dt[,qsec[round(.N/2)],  by=cyl]
```


[official documentation]:https://cran.r-project.org/web/packages/data.table/data.table.pdf

KnitPost(overwriteOne='advanced-data-table', site.path='/Users/ajb/Documents/github/simpleblog/') 

